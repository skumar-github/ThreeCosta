<!doctype html>
 
<html lang="en">
<html>
	<head>
		<title>My first Three.js app</title>
		<style>canvas { width: 100%; height: 100% }</style>
  <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
  <script src="http://code.jquery.com/ui/1.10.1/jquery-ui.js"></script>
  		<script src="https://raw.github.com/mrdoob/three.js/master/build/three.min.js"></script>
		<script src="https://raw.github.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
		<script src="https://raw.github.com/mrdoob/three.js/master/build/Clock.js"></script>
		<script src="./scripts/OBJLoader.js"></script>


	</head>
	<body>
		<script>
		

		var isMouseDown = false;
		var onMouseDownPosition = {};
		
		var torus1;
		var torus2;
		var spheres = [];
		
		var lastClicked = -1;



			//window.onmousedown = onDocumentMouseMove;

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(20, window.innerWidth/window.innerHeight, 0.1, 1000);
			//var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.TorusGeometry( 50, 20, 16, 50, Math.PI * 2);
			var surfaceMaterial = new THREE.MeshLambertMaterial({color: 0x00ff00, shading: THREE.FlatShading});
			surfaceMaterial.side = THREE.DoubleSide;
			var surfaceMaterial2 = new THREE.MeshLambertMaterial({color: 0xb536da, shading: THREE.FlatShading});
			surfaceMaterial2.side = THREE.DoubleSide;			
			var wireframeMaterial = new THREE.MeshBasicMaterial({color: 0x626262, wireframe: true});
			var multiMaterial = [surfaceMaterial, wireframeMaterial];
			var multiMaterial2 = [surfaceMaterial2, wireframeMaterial];

			//var torus = THREE.SceneUtils.createMultiMaterialObject(geometry.clone(), multiMaterial);
			//scene.add(torus);


			var controls = new THREE.TrackballControls(camera);
			

			var pointLight = new THREE.PointLight(0xFFFFFF);
			
			// set its position
			pointLight.position.x = 10;
			pointLight.position.y = 250;
			pointLight.position.z = 250;
			
			// add to the scene
			scene.add(pointLight);

			camera.position.z = 505;
			
			var clock = new THREE.Clock;
			
			
			var loader = new THREE.OBJLoader();
			
			var vertTest = 10;
	        //loader.load( "img/male02.obj", function ( object ) {
	        loader.load( "./obj/0.obj", function ( object ) {
	                    //object.position.y = - 80;
	                    var ge = object.children[0].geometry;
	                    ge.dynamic = true;
	                    
	                    
						
						//makePointSphere(scene, ge.vertices[vertTest]);

	                    torus1 = THREE.SceneUtils.createMultiMaterialObject(ge, multiMaterial);
	                    //torus1.scale.set(.5,.5,.5)
						scene.add(torus1);
						//console.log(torus1.children[0].geometry.vertices)
	                    //scene.add( object );
	                } );
	                
	         loader.load( "./obj/100.obj", function ( object ) {
	                    //object.position.y = - 80;
	                    var ge = object.children[0].geometry;
	                    ge.dynamic = true;
	                    
	                    
	                    //makePointSphere(scene, ge.vertices[vertTest]);


	                    torus2 = THREE.SceneUtils.createMultiMaterialObject(ge, multiMaterial2);
						//torus2.scale.set(.5,.5,.5)
						//scene.add(torus2);
	                } );

			function render() {
				requestAnimationFrame(render);

				//torus.rotation.x += 0.01;
				//torus.rotation.y += 0.01;
				
				// Fetch the delta from THREE.js' clock.
			    var delta = clock.getDelta();
			    // Pass it to the camera controller.
			    controls.update(delta);

				renderer.render(scene, camera);
			}
			render();
			

	   function makePointSphere(scene, position, color){
	   	
	   	  if (!color) color = 0xCC0000;
          var sphereMaterial =
		  new THREE.MeshLambertMaterial(
		    {
		      color: color
		    });

            var sphere = new THREE.Mesh(

			  new THREE.SphereGeometry(
			    1,
			    5,
			    5),
			
			  sphereMaterial);
			
			sphere.position = position;
			// add the sphere to the scene
			scene.add(sphere);
			spheres.push(sphere);
	   }
			 
	   function onDocumentMouseDown(event) {
		    //isMouseDown = true;
		    //console.log("Click");
		    //onMouseDownPosition.x = e.pageX;
		    //onMouseDownPosition.y = e.pageY;
		    
 			//console.log('Morphable-body-obj: Width '+ window.innerWidth ) ;
            //console.log('Morphable-body-obj: Height '+ window.innerHeight) ;
			if (event.button == 0){ // left click only!
				var projector = new THREE.Projector();
			    var x = event.clientX;
			    var y = event.clientY;
			    var v = new THREE.Vector3((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1, 0.5);
			    
			    //projector.unprojectVector(v, camera);
			    //var ray = new THREE.Raycaster(camera.position, v.sub(camera.position).normalize());
			    //var mouse2D = new THREE.Vector3( x, y, 0.5 );
			    var ray = projector.pickingRay( v, camera );
	            //console.log(ray)
	            var intersects = ray.intersectObjects([torus1], true);
	            //console.log("intersects: ", intersects);
	            if (intersects.length > 0)
	              {
	              	/*
	                var xhr = new XMLHttpRequest();
	                xhr.open('GET', '/img/originalMeanModel.obj', false);
	                xhr.send(null);
	                var text = xhr.responseText;
	                var origText = text; 
	                var lines = text.split("\n");
	                for (i=0; i<6449; i++){
	                  lines[i] = lines[i].split(" ");
	                }
	                var low = Math.sqrt(
	                      (Math.pow((intersects[0].point.x - parseFloat(lines[0][1])), 2))+
	                      (Math.pow((intersects[0].point.y - parseFloat(lines[0][2])), 2))+
	                      (Math.pow((intersects[0].point.z - parseFloat(lines[0][3])), 2))
	                    );
	
	                var c = 0;
	                for(i=1; i<6449; i++){
	                  var temp = Math.sqrt(
	                      (Math.pow((intersects[0].point.x - parseFloat(lines[i][1])), 2))+
	                      (Math.pow((intersects[0].point.y - parseFloat(lines[i][2])), 2))+
	                      (Math.pow((intersects[0].point.z - parseFloat(lines[i][3])), 2))
	                  );
	                  if(temp < low){
	                    low = temp;
	                    c=i;
	                  }
	                }
	
	                console.log(
	                  'Mouse coordinates:' + '\nx = ' + intersects[0].point.x + '\ny = ' + intersects[0].point.y + '\nz = ' + intersects[0].point.z +'\n'+
	                  'Nearest Vertex' + '\nx= ' + lines[c][1] + '\ny= ' + lines[c][2] + '\nz =' + lines[c][3] + "\n" +
	                  'Difference' + '\nx= ' + (intersects[0].point.x - lines[c][1]) + '\ny= ' + (intersects[0].point.y - lines[c][2]) + '\nz= ' + (intersects[0].point.z - lines[c][3]) 
	                );*/
	
	                //intersects[0].object.material.color = new THREE.Color( Math.random() * 0xffffff );
	                
	                var lowest;
	                var lowestDist;
	                var verts = torus1.children[0].geometry.vertices;
	                for (var i=0;i<verts.length;i++){
	                	if (i==0) {
	                		lowest = i;
	                		lowestDist = verts[i].distanceTo(intersects[0].point);
	                		continue;
	                	}
	                	else{
	                		var currDist = verts[i].distanceTo(intersects[0].point);
	                		//console.log("currDust: ", currDist)
	                		if (currDist < lowestDist){
	                			lowest = i;
	                			lowestDist = currDist;
	                		}
	                		
	                		if (currDist == lowestDist && i!=lowest){
	                			console.log("MATCH LOWEST: " + i + " " + lowest + " " + currDist)
	                		}
	                	}
	                	//console.log("lowest dist: ", lowestDist)
	                }
	                //console.log(lowest, verts[lowest]);
					makePointSphere(scene, verts[lowest], 0xffb100);
					if (lowest != lastClicked){
						console.log(lowest);// , verts[lowest])
						lastClicked = lowest;	
					}
					//makePointSphere(scene, intersects[0].point, 0xffb100);
	                //intersects[0].face.color = new THREE.Color(0xffffff);
	                //intersects[0].object.geometry.colorsNeedUpdate = true;
	                //intersects[0].object.geometry.dynamic = true;
	               }
	            else{
	                //alert('error');
	                //console.log('Nothing');
	            }
            }
		};

					 document.addEventListener( 'click', onDocumentMouseDown, false );
					 
					 
			    document.onkeypress = function(e) {
				    e = e || window.event;
				    var charCode = (typeof e.which == "number") ? e.which : e.keyCode;
				    if (charCode) {
				        //alert("Character typed: '" + String.fromCharCode(charCode) + "'");
				        if (String.fromCharCode(charCode) == "r"){
				        	//console.log("CLEARING")
				        	for (var i=0;i<spheres.length;i++){
				        		//console.log("REMOVING SPHERE: ", i)
				        		scene.remove(spheres[i]);
				        		lastClicked = -1;
				        	}
				        	spheres = [];
				        	
				        }
				    }
				};
		</script>
	</body>




</html>